<?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>卢克</title>
    <link href="http://geeklu.com/feed/" rel="self" />
    <link href="http://geeklu.com" />
    <lastBuildDate>2016-06-30T23:08:43+08:00</lastBuildDate>
    <webMaster>kejinlu@gmail.com</webMaster>
    
    <item>
      <title>关于Xcode7中的tbd文件</title>
      <link href="http://geeklu.com/2016/03/tbd-file/"/>
      <pubDate>2016-03-31T00:00:00+08:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2016/03/tbd-file</guid>
      <content:encoded><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/65cc0af7jw1f2gfe8bc7yj20ax0ckwg6.jpg" style="width: 50%; height: 50%" />​</p>

<p>tbd 是 <strong>text-based stub libraries</strong>的意思，
是苹果在Xcode7中使用的一个技术，便于减少Xcode7中SDK的体积。 <br />
下面讲解下Xcode7如何通过tbd这个技术减少SDK的大小的。
Xcode7中和各个平台相关的sdk都在<code>/Applications/Xcode.app/Contents/Developer/Platforms</code> 这个目录下，你可以看到如下的一些平台：</p>

<p>这里列出了平台的名字 以及对应的动态链接库所需要的架构</p>

<pre><code>MacOSX (i386,x86_64)
iPhoneOS (armv7, armv7s, arm64)
iPhoneSimulator (i386,x86_64)
AppleTVOS (arm64)
AppleTVSimulator (x86_64)
WatchOS (armv7k)
WatchSimulator (i386)
</code></pre>

<p>每个平台的SDK都在对应的<code>Developer/SDKs/</code>的子目录下，比如iPhoneOS的sdk在<code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk</code>下，
每一个SDK目录下都会包含相应的<strong>动态Framework</strong>以及<strong>dylib</strong>库,分别在SDK目录下的<code>System/Library/Frameworks</code>和<code>/usr/lib</code>目录下。 <br />
在使用tbd之前不管是哪个平台，Framework以及各个单独的dylib库的二进制都得放进来，数量多，体积大。但是真正有必要的其实只是各个模拟器要用的动态库，因为MacOSX的库系统自带，那些诸如iPhoneOS，AppleTVOS，WatchOS这些设备要用的动态库，也只是在设备上真正运行的时候才需要，编译的时候只需要一些简单的信息，符号表啥的，编译通过就好了，真正到设备上去跑的时候才真正需要整个动态库的二进制文件。 <br />
所以为了节省Xcode的体积，苹果创造了一种tbd文件，用作替代那些设备SDK下的动态库，这里我们以<code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks/CFNetwork.framework</code>这个动态Framework库为例，进入到CFNetwork.framework目录下你会看到一个<strong>CFNetwork.tbd</strong>文件，cat下</p>

<pre><code>---
archs:           [ armv7, armv7s, arm64 ]
platform:        ios
install-name:    /System/Library/Frameworks/CFNetwork.framework/CFNetwork
current-version: 758.3.15
exports:         
  - archs:           [ armv7, armv7s, arm64 ]
    symbols:         [ '$ld$hide$os4.3$_NSHTTPCookieComment', '$ld$hide$os4.3$_NSHTTPCookieCommentURL', 
                       '$ld$hide$os4.3$_NSHTTPCookieDiscard', '$ld$hide$os4.3$_NSHTTPCookieDomain', 
                       '$ld$hide$os4.3$_NSHTTPCookieExpires', '$ld$hide$os4.3$_NSHTTPCookieLocationHeader', 
                       '$ld$hide$os4.3$_NSHTTPCookieManagerAcceptPolicyChangedNotification', 
                       '$ld$hide$os4.3$_NSHTTPCookieManagerCookiesChangedNotification', 
                       '$ld$hide$os4.3$_NSHTTPCookieMaximumAge', '$ld$hide$os4.3$_NSHTTPCookieName', 
                       '$ld$hide$os4.3$_NSHTTPCookieOriginURL', '$ld$hide$os4.3$_NSHTTPCookiePath', 
                       '$ld$hide$os4.3$_NSHTTPCookiePort', '$ld$hide$os4.3$_NSHTTPCookieSecure', 
                       '$ld$hide$os4.3$_NSHTTPCookieValue', '$ld$hide$os4.3$_NSHTTPCookieVersion', 
                       '$ld$hide$os4.3$_NSNetServicesErrorCode', '$ld$hide$os4.3$_NSNetServicesErrorDomain',

.......
</code></pre>

<p>你会发现其实tbd文件就是一个文本文件，其中包含架构信息，以及在真实运行时候二进制所在的位置，以及包含了动态库的符号表还有类的一些信息，这些信息在编译阶段足够了。<strong><em>通过通过这种技术，可以大大减少所有的设备SDK的二进制动态库的体积，其中包含MacOSX，iPhoneOS，AppleTVOS，WatchOS</em></strong>。 <br />
模拟器SDK的动态库依然是原始的动态库二进制文件,这点你可以进到<code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CFNetwork.framework</code>目录下进行验证。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>iOS VoiceOver Programming Guide</title>
      <link href="http://geeklu.com/2016/03/ios-voiceover-programming-guide/"/>
      <pubDate>2016-03-07T00:00:00+08:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2016/03/ios-voiceover-programming-guide</guid>
      <content:encoded><![CDATA[<h2 id="section">前言</h2>

<p>VoiceOver是苹果“读屏”技术的名称，属于辅助功能的一部分。VoiceOver可以读出屏幕上的信息，以帮助盲人进行人机交互。
这项技术在苹果的各个系统中都可以看到，OS X，iOS，watchOS，甚至tvOS。
苹果公司的VoiceOver在2015年6月18日获得了美国盲人基金会（American Foundation for the Blind, AFB）颁发的海伦凯勒成就奖，成为全球首家获得此殊荣的科技公司。
单从iOS来说，iOS的VoiceOver功能可以毫不夸张的说是三大移动平台中做的最好的。</p>

<p>虽然说苹果默认的UI组件都已经默认支持VoiceOver功能了，但是通常情况下App还是需要对VoiceOver进行适配和优化的，比如说一些自定义复杂UI组件。</p>

<h2 id="section-1">基本使用</h2>
<p>iPhone上开启VoiceOver功能后，就可以通过 <strong>单指左右轻扫</strong> 来遍历当前界面中的所有的AccessibilityElement（可以被VoiceOver访问的UI元素）,当一个AccessibilityElement被选中后，VoiceOver会将AccessibilityElement的信息读出来。 <strong>单指轻点两次</strong> 能够激活当前元素对应的操作，比如当前AccessibilityElement是一个按钮，那么对应的就是按钮的Action事件。</p>

<p>简单点来说在App开发过程中关于VoiceOver我们需要关注如下几点：</p>

<ul>
  <li>界面上的AccessibilityElement有哪些</li>
  <li>AccessibilityElement的位置和形状</li>
  <li>AccessibilityElement的信息是什么（就是Element被选中后，被读出来内容）</li>
  <li>AccessibilityElement所能响应的的事件有哪些</li>
</ul>

<p>UIKit中的控件基本都是 VoiceOver Ready的，即使是UIView，你也可以通过简单的设置其实变成AccessibilityElement。所以这一小节中所讲的AccessibilityElement其实都是UIView或其子类的实例。 <br />
相关属性和方法基本都在<code>UIAccessibility.h</code>这个头文件中进行了声明。</p>

<p>所以简单的情况下通过UIView的<code>isAccessibilityElement</code>属性就可以控制某个View是否是AccessibilityElement，在UIKit的控件中，像UILabel，UIButton 这些控件的isAccessibilityElement属性默认就是true的，UIView这个属性默认是false。</p>

<p>一般情况下AccessibilityElement的位置和形状是通过accessibilityFrame进行设置的，默认值是View在屏幕中的位置，形状就是View的矩形形状。如果你想自己设置accessibilityFrame的值，那么得注意下，这边的frame值是相对于设备Screen的坐标系的，当然可以通过UIAccessibilityConvertFrameToScreenCoordinates函数来帮助转换。此函数有两个参数，一个rect，一个是view， 其含义就是将相对于view这个坐标系的rect转换成相对于screen坐标系的值并返回。所以一般情况下 rect可以是目标Element在父View中的frame，view就为其父view。</p>

<pre><code>public func UIAccessibilityConvertFrameToScreenCoordinates(rect: CGRect, _ view: UIView) -&gt; CGRect
</code></pre>

<p>如果你想设置非矩形的形状，你也可以通过给 <strong>accessibilityPath</strong> 属性指定一个UIBezierPath类型的值来自定义AccessibilityElement的形状。</p>

<p>至于AccessibilityElement的信息可以通过下面几个UIAccessibility的属性来决定</p>

<ul>
  <li>accessibilityLabel  这是什么</li>
  <li>accessibilityHint 这个有什么用，会产生什么样的结果</li>
  <li>accessibilityValue 这个的 <strong>值</strong> 是什么</li>
  <li>accessibilityTraits 这个的类型以及状态，就是通过traits来表征这个Element的特质，数据类型是一个枚举类型，可以通过按位或的方式合并多个特性。</li>
</ul>

<p>这里有个需要注意的就是，当某个View的是AccessibilityElement的时候 ，其subviews都会被屏蔽掉，这个特性有时候还是有用的，比如一个View中包含多个Label，那么你希望每一个下面的Label不要单独可以访问到，那么你可以将这个View设置成可以访问的，然后将其accessibilityLabel设置为所有子Label的accessibilityLabel的合并值。</p>

<p>至于AccessibilityElement的事件，最简单的莫过于上面提到 <strong>单指轻点两次</strong> 能够激活当前元素对应的操作了,如果当前AccessibilityElement实现的<code>public func accessibilityActivate() -&gt; Bool</code>这个方法返回true，那边此逻辑将被调用，否则相当于在AccessibilityElement的accessibilityActivationPoint这个位置点上进行了一次Tap操作。</p>

<h2 id="section-2">高级特性</h2>
<p>#### Accessibility Container
设想下这样的一个场景，一个UIView，内部包含一组用户可以进行交互的内容，每一个内容之间是独立的，但是这些内容不是以子View的形式存在，而是通过Quarz 2D或者Core Text渲染而成，所以这部分内容无法通过上面的方式变成AccessibilityElement。这种情况UIView需要按照UIAccessibilityContainer的方式，来将内部的每一个独立的内容都描述成UIAccessibilityElement的实例，这个时候这个UIView我们称之为Accessibility Container。</p>

<p>接下来讲解具体的实现步骤了。
先说说iOS 8之后如何实现，首先Accessibility Container的isAccessibilityElement值必须设置为false，另外我们需要创建出所有的UIAccessibilityElement的实例，然后赋给accessibilityElements属性（iOS 8.0+）
假设在一个UIView的子类中，通过叫做updateAccessibleElements的方法来更新维护所有的UIAccessibilityElement实例，当界面上的内容发生变化，或者VoiceOver开启关闭状态发生变化时，调用此方法以更新accessibilityElements，相关伪代码如下：</p>

<pre><code>    internal func updateAccessibleElements() {
        guard UIAccessibilityIsVoiceOverRunning() else {
            self.accessibilityElements = nil
            return
        }
        
        self.isAccessibilityElement = false
        var elements = [AnyObject]()

        let element1 = UIAccessibilityElement(accessibilityContainer: self)
        element1.accessibilityLabel = "element1"
        element1.accessibilityTraits = UIAccessibilityTraitStaticText
        element1.accessibilityFrame = UIAccessibilityConvertFrameToScreenCoordinates(element1FrameInSelf, self)
        elements.append(element1)
        ...
        self.accessibilityElements = elements
    }

</code></pre>

<p>如果是iOS 8以下，那么就需要实现下面的几个方法来实现了，比较繁琐：</p>

<pre><code>// accessibilityElement的个数
public func accessibilityElementCount() -&gt; Int

// 返回指定Index的accessibilityElement
public func accessibilityElementAtIndex(index: Int) -&gt; AnyObject?

// 返回指定accessibilityElement的Index
public func indexOfAccessibilityElement(element: AnyObject) -&gt; Int
</code></pre>

<p>使用上面第二种方式的时候，往往需要自己维护一个包含所有accessibilityElements的数组，然后通过数组来完成上面的这三个方法的返回。这种方法比较累赘，而且当界面更新需要刷新内容的时候，还需要发送通知系统，告诉系统界面上的accessibilityElements有变动需要更新。所以最小版本定位于iOS 8的情况下还是直接设置accessibilityElements属性的方式比较科学。</p>

<p>关于UIAccessibilityElement这个类的设计还是存在一些疑惑的，既然NSObject的UIAccessibility扩展已经包含了诸如<code>accessibilityLabel</code>,<code>accessibilityHint</code>这些属性，为何UIAccessibilityElement类中还需要重复声明这些属性，有点重复的感觉。</p>

<h4 id="actions">Actions</h4>
<p>之前只讲到了最简单的事件，就是单指轻点两下，其实常见的Actions有下面这些，每一个Action都会对应一个方法，可以通过覆盖方法的方式来自定义Action对应的逻辑：</p>

<ul>
  <li>Activate 单指轻点两次  <br />
 <code>public func accessibilityActivate() -&gt; Bool</code></li>
  <li>Escape. 单指 Z-shaped 手势一般用于退出模态界面或者返回导航的上一页界面  <br />
<code>public func accessibilityPerformEscape() -&gt; Bool</code></li>
  <li>Magic Tap. 双指轻点两次触发 most-intended action.    <br />
 <code>public func accessibilityPerformMagicTap() -&gt; Bool</code></li>
  <li>Three-Finger Scroll. 三指滑动触发界面水平或者垂直的滚动  <br />
 <code>public func accessibilityScroll(direction: UIAccessibilityScrollDirection) -&gt; Bool</code></li>
  <li>Increment. 单指向上滑动，需要设置accessibilityTraits为UIAccessibilityTraitAdjustable，否则对应的方法不会被调用  <br />
 <code>public func accessibilityIncrement()</code></li>
  <li>Decrement. 单指向下滑动，需要设置accessibilityTraits为UIAccessibilityTraitAdjustable，否则对应的方法不会被调用 <br />
 <code>public func accessibilityDecrement()</code></li>
</ul>

<p>这些方法中，其中Escape，Magic Tap，Three-Finger Scroll这几种手势支持在响应链中向上寻找对应的Action方法，首先用户在屏幕上进行相应的手势，系统检查当前VoiceOver的Focus的Element有无实现对应的方法，没有实现的话，则向响应链的上一级寻找。比如有些全局性的操作，对应的方法写在上层View或者ViewController中比较合适。
其实很多系统提供的组件都默认实现了一些VoiceOver的手势Action，比如UINavigationController, UIAlertController 都提供了对Escape手势的支持。</p>

<h4 id="accessibility-notification">Accessibility Notification</h4>
<p>Accessibility提供了一系列的通知，可以完成一些特定的需求。比如你可以监听<code>UIAccessibilityVoiceOverStatusChanged通知，来监控Voice Over功能开启关闭的实时通知 </code>。</p>

<p>或者是你在App中主动发送一些通知，来让系统做出一些变化，比如当你界面上的AccessibilityElement有变动的时候你可以发送<code>UIAccessibilityLayoutChangedNotification</code>通知，通知发送时使用UIAccessibility的专用的函数,UIAccessibilityPostNotification函数有两个参数，第一个是通知名，第二个是你想让VoiceOver读出来的字符串或者是新的VoiceOver的焦点对应的元素。</p>

<pre><code>UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, self.myFirstElement)
</code></pre>

<h2 id="section-3">建议</h2>

<ul>
  <li>AccessibilityElement的信息尽量简洁，accessibilityLabel不要包含提示性质的文案，避免信息干扰</li>
  <li>TableView的每一个Cell的信息尽量合并，使得Cell变成一个整体的AccessibilityElement，避免无意义的冗余元素之间切换的操作。Cell中有多个按钮的时候，可以考虑使用Magic Tap的方式，Magic Tap的Action中弹出sheet样式的UIAlertController来供用户操作。</li>
  <li>自定义的模态页面注意设置accessibilityViewIsModal为true，最好支持Escape手势
的方式退出模态页面。</li>
  <li>将页面中装饰用的没有实际意义的元素的accessibilityElementsHidden设置成true，减少操作过程中的干扰</li>
</ul>

<hr />

<p>参考文档:
<a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIAccessibility_Protocol/index.html">UIAccessibility Protocol</a>
<a href="https://developer.apple.com/library/prerelease/ios/featuredarticles/ViewControllerPGforiPhoneOS/SupportingAccessibility.html">Supporting Accessibility</a>
<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/iPhoneAccessibility/Accessibility_on_iPhone/Accessibility_on_iPhone.html">Accessibility Programming Guide for iOS</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Handoff Between iOS App &amp; Website</title>
      <link href="http://geeklu.com/2015/04/handoff-between-native-app-and-web-browser/"/>
      <pubDate>2015-04-01T00:00:00+08:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2015/04/handoff-between-native-app-and-web-browser</guid>
      <content:encoded><![CDATA[<h3 id="handoff">一.Handoff的基本常识</h3>

<p>iOS 8以及Mac OS X Yosemite之后引入了一个新的功能特性：Handoff。Handoff也就是Continuity特性，连续互通，比如你用iPhone写邮件写到一半想在Mac上继续写，或者Mac上看到一个网页想在手机上浏览，这些便是Handoff的使用场景了。</p>

<p>Handoff的支持有一些硬性的要求：</p>

<ul>
  <li>互通的所有设备必须支持 Buletooth LE 4.0，Handoff使用BLE信号来传递用户活动数据。</li>
  <li>设备处于联网状态，有时候有些数据还是会通过互联网来传递的，比如Mail App的邮件内容的同步。</li>
  <li>所有设备必须连到同一个iCloud账户。</li>
  <li>当然你还得保证当前设备的Handoff功能打开了(iOS:设置-&gt;通用-&gt;Handoff 与建议的应用程序。 Mac:系统偏好设置-&gt;通用,倒数第二栏有个选项,”允许这台Mac和iCloud设备之间使用Handoff”)</li>
</ul>

<p>BLE并不像传统的蓝牙，并不需要人工手动进行配对，只要打开就行了，所有的配对数据传输都是自动完成的；设备并不一定需要连在同一个WIFI网络中，Handoff的活动数据通过BLE进行传递，保证及时性以及数据的安全性，你可以在使用过程中尝试将WIFI或者网络关闭，设备还是可以接受到Handoff的通知的。</p>

<p>苹果已经对很多内置的App做了Handoff支持，如Safari浏览器，邮件，电话，消息，提醒事项等都是支持的，在你开始Handoff编程之前可以先使用这些App进行Handoff功能的体验。</p>

<h3 id="ios-app--web-browser">二.iOS App 到 Web Browser</h3>

<p>Handoff编程的核心类便是NSUserActivity了，代表着一个用户的活动，每一个Activity都有一个activityType，用来标识Activity的类型。当App 到 App之间进行Handoff的话，那么接受方需要满足几个条件</p>

<ul>
  <li>App必须是通过发布证书或者开发者证书进行打包的</li>
  <li>和发布Activity的App拥有相同的TeamID</li>
  <li>info.plist中声明了接受的Activity的activityType(key 为 NSUserActivityTypes)</li>
</ul>

<p>不过很多应用其实也只是在移动设备上有App，在Mac上绝大多数还是走的浏览器，所以iOS App和浏览器的Handoff的需求就变的很常见了。这个时候Activity的另一个叫做webpageURL的属性便有用武之地了，当没有合适的App能够处理当前的Activity的话，系统会转给默认的浏览器进行处理（当然你的这个默认的浏览器的info.plist的NSUserActivityTypes数组中必须声明了 NSUserActivityTypeBrowsingWeb这个type，目前Mac版本的Chrome已经支持了）。</p>

<pre><code>self.myActivity = [[NSUserActivity alloc] initWithActivityType: @"com.taobao.handoff.act.home"];
self.myActivity.webpageURL = [NSURL URLWithString:@"http://www.taobao.com"];
[self.myActivity becomeCurrent];
</code></pre>

<p>当上面的代码执行之后，Activity便会进行分发，接受者接受后，若没有App能够处理当前类型的Activity的话便转交给默认的浏览器去处理了，这里需要特别注意的就是activity的生命周期，当activity被invalidate或者被释放了，那么这个Handoff消息也就消失了，相关设备的Handoff消息就会消失。</p>

<p>关于Handoff的调试，由于到目前为止模拟器还是没有支持Handoff的，所以你必须使用开发者证书进行真机调试。</p>

<h3 id="web-browser--ios-app">三.Web Browser 到 iOS App</h3>

<p>相比于App到Web Browser，Web Browser到iOS App的Handoff实现起来就复杂一些了。
首先先描述下大体的流程：</p>

<ol>
  <li>首先在Mac上使用Safari浏览器浏览目标网站，Handoff消息会通过BLE进行分发</li>
  <li>iOS设备接收到Handoff消息后，检查对应的webpageURL，看是否有某个App的associated-domains （entitlement中的一项）中包含了这个webpageURL, associated-domains对应的Handoff的配置URL样式为 activitycontinuation:example.com</li>
  <li>如果某个App的associated-domains存在相应的webpageURL,那么iOS会去这个网站的固定的一个URL（地址为https://example.com/apple-app-site-association）获取一个签名过的文件（源文件为一个JSON文件）,如果解密后文件中的App IDs中包含了 之前匹配的App的App ID，那么这个Activity便交给这个匹配的App进行处理。</li>
</ol>

<p>下面讲解详细的操作步骤</p>

<h4 id="section">1.客户端</h4>
<p>首先当然还是折腾客户端工程，当你创建好工程，创建好App ID，XCode中设置好自己的Developer账户之后，你便可以设置编译的Code Sign的相关东西了，配置都得选自动的，这样就可以通过XCode来管理配置 App ID 以及相应的 Provisioning Profiles了，当你通过developer后台网站就可以看到Provisioning Profiles中有一堆所谓的Managed by Xcode的条目了。</p>

<p>你需要在XCode工程对应的Target的Capabilities这个Tab中开启Associated Domains，这个时候时候你可能会遇到错误提示“You must be a team admin or agent in order to enable this capability.”,其实即使账户是admin还是会报错，这个可能是XCode的bug吧，你需要切换到General这个tab中将Team先选None，然后再切换到你对应的Team，这个时候Team下方显示错误了，其实就是你更改了Entitlements，而这个和Provisioning Profiles有关联，所以你的Provisioning Profiles也需要重新更新，点击Team下方的Fix Issue按钮，等待重新下载新的Provisioning Profiles，然后回到Capabilities这个tab你会发现刚才的错误已经不见了。</p>

<p>其实Capabilities中的操作除了会在本地生成entitlements文件，还会同步到developer后台去，会修改app对应的App ID的配置，以及在developer后台生成新的Provisioning Profiles。这些东西都和打包签名息息相关。</p>

<p>接着在Associated Domains下加上所需要支持handoff的domains</p>

<pre><code>activitycontinuation:taobao.com
</code></pre>

<p>activitycontinuation是服务名，taobao.com是支持的域名
当Mac上的浏览器访问一个网站的时候，此网站的域名如果被某个App的Associated Domains包含了，那么Handoff底层会去这个域名一个指定的路径下访问一个文件，这个指定的路径便是 :
https://taobao.com/apple-app-site-association ,这个路径需要返回一个签名过的文件数据，里面指定了当前网站所支持Handoff的App ID们，这个下面会提及到</p>

<h4 id="section-1">2.服务器端</h4>
<p>需要进行Handoff的网站，需要在https的特定的路径下放一个签名过的文件，这个文件里面指明了Handoff支持哪些App（Domain-approved apps IDs），这个文件的明文为JSON格式,在对JSON文件签名前最好去掉所有无用的空格以及检测下JSON格式的正确性，避免后面带来问题</p>

<pre><code>{"activitycontinuation":{"apps":["XN6U3EV979.com.taobao.handoff"]}}
</code></pre>

<p>签名则是使用网站的ssl的私钥以及证书进行签名（如果不存在中级证书，那么中级证书可以去掉）</p>

<pre><code>cat json.txt | openssl smime -sign -inkey taobao.com.key
                             -signer taobao.com.pem
                             -certfile intermediate.pem
                             -noattr -nodetach
                             -outform DER &gt; apple-app-site-association
</code></pre>

<p>生成的文件放到网站根目录下以及确保可以通过指定的路径进行访问。</p>

<h4 id="section-2">3.如何进行本机调试</h4>

<p>要想在开发机器上进行网站的Handoff的调试则首先的问题就是SSL证书，你需要自己搞一个CA证书，在Mac上可以通过Keychain Access(钥匙串访问)这个App中的证书助理来生成 。</p>

<p>首先是CA证书,这里生成的是自签名的根证书，CA证书的作用就是给网站的SSL的证书进行签名用的，然后创建网站的SSL证书,一步一步走下去，然后通过刚才的CA证书进行签发，这样生成的证书就可以直接用于网站的SSL证书了。</p>

<p>然后选择一个Web Server，我这里选用的<a href="http://download.eclipse.org/jetty/">Jetty</a>，直接下载下来然后就可以直接使用自带的demo了，主要是需要自己配置下SSL。</p>

<p>将默认的ssl配置拷贝到demo工程相应的目录下
<code>
Luke@LukesMac:~/Workspace/jetty » cp etc/jetty-ssl.xml demo-base/etc/ 
</code></p>

<p>从Keychian Access中导出之前生成的证书文件，导出格式为p12，这样就会包含私钥了。假设导出文件为 lukesmac.p12,导出时候 需要你设置一个密码，你就将其设置为 keypwd
然后需要将这个p12文件导入demo工程的keystore文件中，默认在demo工程的etc目录下已经存在一个keystore文件，直接导入这个keystore</p>

<pre><code>keytool -importkeystore -srckeystore lukesmac.p12 -srcstoretype PKCS12 -destkeystore keystore
</code></pre>
<p>默认keystore的密钥库口令为storepwd,导入的过程中你还需要输入你上面设置的私钥密码（因为jetty-ssl.xml中配置的私钥密码以及默认keystore中的私钥密码默认为keypwd
,所以为了方便上面导出私钥所设置的私钥密码保持一致为keypwd）。最后你还需要在demo工程的根目录下的start.ini中加入一行</p>

<pre><code>etc/jetty-ssl.xml
</code></pre>

<p>然后你就可以开开心心的启动了，</p>

<pre><code>Luke@LukesMac:~/Workspace/jetty/demo-base » java -jar ../start.jar
</code></pre>

<p>然后我便可以通过 https://lukesmac.local:8443/ 进行访问了</p>

<p>下面需要将json.txt进行签名，</p>

<p>首先你需要从上面导出的p12文件中搞出私钥文件，再从Keychain Access中导出一份证书的cer文件</p>

<pre><code>openssl pkcs12 -in lukesmac.p12 -nocerts -out privateKey.pem
cat json.txt | openssl smime -sign -inkey privateKey.pem -signer lukesmac.cer -noattr -nodetach -outform DER &gt; apple-app-site-association
</code></pre>

<p>将生成的apple-app-site-association文件放到 demo工程的ROOT目录下，然后重启以及在浏览器中对这个文件进行访问测试。</p>

<p>这个时候你以为一切就绪了，发现手机上handoff的图标依然是safari，打开后发现，网页根本无法打开，其原因就是自己生成的自签名的CA证书不被信任，这个时候你可以讲CA证书按照cer的格式导出，然后通过邮件发送，在iPhone上的邮箱App中点击这个cer的附件，系统会跳转到设置的描述文件的界面去，你需要进行安装证书，之后这个CA证书签发的SSL证书对于这台设备都是可信任的了。</p>

<p>最后就是客户端添加处理逻辑了，可以在Appdelegate中添加如下方法，就可以对传递过来的userActivity进行处理</p>

<pre><code>- (BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void(^)(NSArray *restorableObjects))restorationHandler NS_AVAILABLE_IOS(8_0);
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>Facebook Pop 使用指南</title>
      <link href="http://geeklu.com/2014/05/facebook-pop-usage/"/>
      <pubDate>2014-05-22T00:00:00+08:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2014/05/facebook-pop-usage</guid>
      <content:encoded><![CDATA[<p>当听闻Facebook要开源自己的Animation框架的时候，我还以为是基于Core Animation进行的封装，包含了一些动画效果库。等源码真正出来后，才发现完全想错了，Facebook Pop其实是基于CADisplayLink(Mac平台上使用的CVDisplayLink)实现的独立于Core Animation之外的动画方案。这里就不细说其实现原理了，主要讲讲Facebook Pop如何使用。</p>

<h2 id="section">一.基本概念</h2>
<p>在计算机的世界里面，其实并不存在绝对连续的动画，你所看到的屏幕上的动画本质上都是离散的，只是在一秒的时间里面离散的帧多到一定的数量人眼就觉得是连续的了，在iOS中，最大的帧率是60帧每秒。
iOS提供了Core Animation框架，只需要开发者提供关键帧信息，比如提供某个animatable属性终点的关键帧信息，然后中间的值则通过一定的算法进行插值计算，从而实现补间动画。 Core Aniamtion中进行插值计算所依赖的时间曲线由CAMediaTimingFunction提供。
Pop Animation在使用上和Core Animation很相似，都涉及Animation对象以及Animation的载体的概念，不同的是Core Animation的载体只能是CALayer，而Pop Animation可以是任意基于NSObject的对象。当然大多数情况Animation都是界面上显示的可视的效果，所以动画执行的载体一般都直接或者间接是UIView或者CALayer。但是如果你只是想研究Pop Animation的变化曲线，你也完全可以将其应用于一个普通的数据对象，比如下面这个对象:</p>

<pre><code>@interface AnimatableModel : NSObject
@property (nonatomic,assign) CGFloat animatableValue;
@end

#import "AnimatableModel.h"
@implementation AnimatableModel
- (void)setAnimatableValue:(CGFloat)animatableValue{
  _animatableValue = animatableValue;
  NSLog(@"%f",animatableValue);
}

@end
</code></pre>

<p>此对象只有一个CGFloat类型的属性，非常简单，这里在AnimatableModel对象上运行几种Pop Animation进行测试，以便统计animatableValue的变化曲线。</p>

<p>由于此对象的属性不在Pop Property的标准属性中，所以需要创建一个POPAnimatableProperty，</p>

<pre><code>  POPAnimatableProperty *animatableProperty = [POPAnimatableProperty propertyWithName:@"com.geeklu.animatableValue" initializer:^(POPMutableAnimatableProperty *prop) {
    prop.writeBlock = ^(id obj, const CGFloat values[]) {
        [obj setAnimatableValue:values[0]];
    };
    prop.readBlock = ^(id obj, CGFloat values[]) {
        values[0] = [obj animatableValue];
    };
}];
</code></pre>

<p>统计的数据来自上面属性变化时的Log数据，制图的时候将时间中除了秒之外的时间部分删除了，所有数据都来自真实测试的数据，并使用Number进行了曲线的绘制。图中的每个点代表一个离散的节点，为了方便观看，使用直线将这些离散的点连接起来了。</p>

<p><img src="http://ww4.sinaimg.cn/mw1024/65cc0af7gw1ego7boez1uj20oc0icju4.jpg" style="width: 50%; height: 50%" />​</p>

<h3 id="popbasicaniamtion-with-easeout-timingfunction">PopBasicAniamtion With EaseOut TimingFunction</h3>

<pre><code>POPBasicAnimation *animation = [POPBasicAnimation animation];
animation.property = animatableProperty;
animation.fromValue = [NSNumber numberWithFloat:0];
animation.toValue = [NSNumber numberWithFloat:100];
animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];
animation.duration = 1.5;

_animatableModel = [[AnimatableModel alloc] init];
[_animatableModel pop_addAnimation:animation forKey:@"easeOut"];
</code></pre>

<p><img src="http://ww1.sinaimg.cn/mw1024/65cc0af7gw1egnh3razkxj20sy0kadh2.jpg" style="width: 50%; height: 50%" />​</p>

<p>从上图可以看到，动画开始的时候变化速率较快，到结束的时候就很慢了，这就是所谓的Ease Out效果。</p>

<h3 id="popspringaniamtion">PopSpringAniamtion</h3>

<pre><code>POPSpringAnimation *animation = [POPSpringAnimation animation];
animation.property = animatableProperty;
animation.fromValue = [NSNumber numberWithFloat:0];
animation.toValue = [NSNumber numberWithFloat:100];
animation.dynamicsMass = 5;

_animatableModel = [[AnimatableModel alloc] init];
[_animatableModel pop_addAnimation:animation forKey:@"spring"];
</code></pre>

<p><img src="http://ww4.sinaimg.cn/mw1024/65cc0af7gw1egnh8m1lhtj20oi0gg0u4.jpg" style="width: 50%; height: 50%" />​</p>

<p>一开始快速向终点方向靠近，然后会在终点附近来回摆动，摆动幅度逐渐变弱，最后在终点停止。</p>

<p>通过上面的两个属性值变化的曲线你可以很好的理解动画的类型和属性的变化曲线之前的关联了。
## 二.Pop Animation的使用
这里就讲讲Pop Aniamtion自带的几种动画的使用。 Pop Animation自带的动画都是基于POPPropertyAnimation的，POPPropertyAnimation有个很重要的部分就是 POPAnimatableProperty，用来描述animatable的属性。上一节中就看到了如何来创建一个POPAnimatableProperty对象，在初始化的时候，需要在初始化的block中设置writeBlock和readBlock</p>

<pre><code>void (^readBlock)(id obj, CGFloat values[])
void (^writeBlock)(id obj, const CGFloat values[])
</code></pre>

<p>这两个block都是留给动画引擎来使用的，前者用于向目标属性写值,使用者需要做的就是从values中提取数据设置给obj；后者用于读取，也就是从objc中读取放到values中。values[] 最多支持4个数据，也就是说Pop Aniamtion属性数值的维度最大支持4维。
为了使用便捷，Pop Animation框架提供了很多现成的POPAnimatableProperty预定义，你只需要使用预定义的propertyWithName来初始化POPAnimatableProperty便可，比如以下一些预定义的propertyWithName：</p>

<pre><code>kPOPLayerBackgroundColor
...
kPOPViewAlpha
...
</code></pre>

<p>这样预定义的POPAnimatableProperty已经帮你设置好writeBlock和readBlock。
下面的一些基于POPPropertyAnimation的动画都提供了快捷的方法，直接传入propertyWithName便创建好了特定property的动画了。
下面列举的各个实例都可以在这里找到：<a href="https://github.com/kejinlu/facebook-pop-sample">https://github.com/kejinlu/facebook-pop-sample</a>。</p>

<h3 id="popbasicanimation">1.POPBasicAnimation</h3>
<p>基本动画，接口方面和CABasicAniamtion很相似，使用可以提供初始值fromValue，这个 终点值toValue，动画时长duration以及决定动画节奏的timingFunction。timingFunction直接使用的CAMediaTimingFunction,是使用一个横向纵向都为一个单位的拥有两个控制点的贝赛尔曲线来描述的，横坐标为时间，纵坐标为动画进度。
<img src="http://ww2.sinaimg.cn/mw1024/65cc0af7gw1egpvtrn8qmj209307qdhf.jpg" style="width: 50%; height: 50%" />​
这里举一个View移动的例子：</p>

<pre><code>NSInteger height = CGRectGetHeight(self.view.bounds);
NSInteger width = CGRectGetWidth(self.view.bounds);

CGFloat centerX = arc4random() % width;
CGFloat centerY = arc4random() % height;

POPBasicAnimation *anim = [POPBasicAnimation animationWithPropertyNamed:kPOPViewCenter];
anim.toValue = [NSValue valueWithCGPoint:CGPointMake(centerX, centerY)];
anim.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
anim.duration = 0.4;
[self.testView pop_addAnimation:anim forKey:@"centerAnimation"];
</code></pre>

<p>这里self.view上放了一个用于动画的testView，然后取一个随机坐标，进行动画。</p>

<h3 id="popspringanimation">2.PopSpringAnimation</h3>
<p>弹簧动画是Bezier曲线无法表述的，所以无法使用PopBasicAniamtion来实现。PopSpringAnimation便是专门用来实现弹簧动画的。</p>

<pre><code>POPSpringAnimation *anim = [POPSpringAnimation animationWithPropertyNamed:kPOPViewCenter];

NSInteger height = CGRectGetHeight(self.view.bounds);
NSInteger width = CGRectGetWidth(self.view.bounds);

CGFloat centerX = arc4random() % width;
CGFloat centerY = arc4random() % height;

anim.toValue = [NSValue valueWithCGPoint:CGPointMake(centerX, centerY)];
anim.springBounciness = 16;
anim.springSpeed = 6;
[self.testView pop_addAnimation:anim forKey:@"center"];
</code></pre>

<p>&lt;img src=”http://ww1.sinaimg.cn/mw1024/65cc0af7gw1egqpgva69rg208u0fpjtx.gif” style=”width: 25%; height: 25%”;/&gt;​</p>

<p>这个例子的动画和上面的基本动画很相似，都是一个view的移动，但是这里有弹簧效果。POPSpringAnimation主要就是需要注意下几个参数的含义：</p>

<ul>
  <li>springBounciness 弹簧弹力 取值范围为[0, 20]，默认值为4</li>
  <li>springSpeed 弹簧速度，速度越快，动画时间越短 [0, 20]，默认为12，和springBounciness一起决定着弹簧动画的效果</li>
  <li>dynamicsTension  弹簧的张力</li>
  <li>dynamicsFriction 弹簧摩擦</li>
  <li>dynamicsMass 质量  。张力，摩擦，质量这三者可以从更细的粒度上替代springBounciness和springSpeed控制弹簧动画的效果</li>
</ul>

<h3 id="popdecayanimation">3.PopDecayAnimation</h3>
<p>基于Bezier曲线的timingFuntion同样无法表述Decay Aniamtion，所以Pop就单独实现了一个 PopDecayAnimation，用于衰减动画。衰减动画一个很常见的地方就是 UIScrollView 滑动松开后的减速，这里就基于UIView实现一个自己的ScrollView，然后使用PopDecayAnimation实现
此代码可以详细参见 <a href="https://github.com/kejinlu/facebook-pop-sample/blob/master/facebook-pop-sample/KKScrollView.m">KKScrollView</a> 的实现，当滑动手势结束时，根据结束的加速度，给衰减动画一个初始的velocity，用来决定衰减的时长。</p>

<p>&lt;img src=”http://ww3.sinaimg.cn/mw1024/65cc0af7gw1egmzoapnqwg206i0bm7nn.gif” style=”width: 25%; height: 25%”;/&gt;​</p>

<h3 id="popcustomanimation">4.POPCustomAnimation</h3>
<p>POPCustomAnimation 并不是基于POPPropertyAnimation的，它直接继承自PopAnimation用于创建自定义动画用的，通过POPCustomAnimationBlock类型的block进行初始化，</p>

<pre><code>typedef BOOL (^POPCustomAnimationBlock)(id target, POPCustomAnimation *animation);
</code></pre>

<p>此block会在界面的每一帧更新的时候被调用，创建者需要在block中根据当前currentTime和elapsedTime来决定如何更新target的相关属性，以实现特定的动画。当你需要结束动画的时候就在block中返回NO，否则返回YES。</p>

<h2 id="pop-animationcore-animation">四.Pop Animation相比于Core Animation的优点</h2>
<p>Pop Animation应用于CALayer时，在动画运行的任何时刻，layer和其presentationLayer的相关属性值始终保持一致，而Core Animation做不到。 <br />
Pop Animation可以应用任何NSObject的对象，而Core Aniamtion必须是CALayer。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Custom Container View Controller</title>
      <link href="http://geeklu.com/2014/05/custom-container-view-controller/"/>
      <pubDate>2014-05-08T00:00:00+08:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2014/05/custom-container-view-controller</guid>
      <content:encoded><![CDATA[<p>什么是Container View Controller?苹果文档是这么描述的:</p>

<pre><code>A container view controller contains content owned by other view controllers.
</code></pre>

<p>也就是说一个View Controller显示的某部分内容属于另一个View Controller，那么这个View Controller就是一个Container，比如UIKit中的UINavigationController，UITabBarController。 <br />
在iOS 5之前苹果是不允许出现自定义的Container的 ，也就是说你创建的一个View Controller的view不能包含另一个View Controller的view，这对于逻辑复杂的界面来说，不易于功能拆分。也许曾经你为了某个公用的显示逻辑，直接将某个View Controller的view添加到另一个View Controller的view上，然后发现可以正常显示和使用，但实际上这种行为是非常危险的。</p>

<p>iOS 5.0 开始支持Custom Container View Controller，开放了用于构建自定义Container的接口。如果你想创建一个自己的Container，那么有一些概念还得弄清楚。Container的主要职责就是管理一个或多个Child View Controller的展示的生命周期，需要传递显示以及旋转相关的回调。其实显示或者旋转的回调的触发的源头来自于window,一个app首先有一个主window，初始化的时候需要给这个主window指定一个rootViewController，window会将显示相关的回调(viewWillAppear:, viewWillDisappear:, viewDidAppear:, or viewDidDisappear: )以及旋转相关的回调(willRotateToInterfaceOrientation:duration:
,willAnimateRotationToInterfaceOrientation:duration:,
didRotateFromInterfaceOrientation:)传递给rootViewController。rootViewController需要再将这些callbacks的调用传递给它的Child View Controllers。</p>

<h3 id="section">一.父子关系范式</h3>
<p>实现一个Custom Container View Controller并不是一个简单的事情，主要分为两个阶段：父子关系的建立以及父子关系的解除。如果pVC将cVC的view添加为自己的subview，那么cVC必须为pVC的Child View Controller，而反过来则不一定成立，比如UINavigationController，一个View Controller被push进来后便和navigationController建立父子关系了,但是只有最上面的View Controller 是显示着的，底下的View Controller的view则被移出了容器的view的显示层级，当一个View Controller被pop之后，便和navigationController解除了父子关系了。</p>

<p><strong>展示一个名为content的child view controller</strong>：</p>

<pre><code> [self addChildViewController:content];  //1
 content.view.frame = [self frameForContentController]; 
 [self.view addSubview:self.currentClientView]; //2
 [content didMoveToParentViewController:self]; //3
</code></pre>

<p>1.将content添加为child view controller，addChildViewController:接口建立了逻辑上的父子关系，子可以通过parentViewController，访问其父VC，addChildViewController:接口的逻辑中会自动调用 <code>[content willMoveToParentViewController:self];</code><br />
2.建立父子关系后，便是将content的view加入到父VC的view hierarchy上，同时要决定的是 content的view显示的区域范围。 <br />
3.调用child的 didMoveToParentViewController: ，以通知child，完成了父子关系的建立</p>

<p><strong>移除一个child view controller</strong>：</p>

<pre><code> [content willMoveToParentViewController:nil]; //1
 [content.view removeFromSuperview]; //2
 [content removeFromParentViewController]; //3
</code></pre>

<p>1.通知child，即将解除父子关系，从语义上也可以看出 child的parent即将为nil<br />
2.将child的view从父VC的view的hierarchy中移除 <br />
3.通过removeFromParentViewController的调用真正的解除关系，removeFromParentViewController会自动调用 [content didMoveToParentViewController:nil]</p>

<h3 id="appearance-callbacks">二.appearance callbacks的传递</h3>
<p>上面的实现中有一个问题，就是没看到那些appearance callbacks是如何传递的，答案就是appearance callbacks默认情况下是自动调用的，苹果框架底层帮你实现好了，也就是在上面的addSubview的时候，在subview真正加到父view之前，child的viewWillAppear将被调用，真正被add到父view之后，viewDidAppear会被调用。移除的过程中viewWillDisappear，viewDidDisappear的调用过程也是类似的。<br />
有时候自动的appearance callbacks的调用并不能满足需求，比如child view的展示有一个动画的过程，这个时候我们并不想viewDidAppear的调用在addSubview的时候进行，而是等展示动画结束后再调用viewDidAppear。也许你可能会提到 <code>transitionFromViewController:toViewController:duration:options:animations:completion:</code> 这个方法，会帮你自动处理view的add和remove，以及支持animations block，也能够保证在动画开始前调用willAppear或者willDisappear，在调用结束的时候调用didAppear，didDisappear，但是此方式也存在局限性，必须是两个新老子VC的切换，都不能为空，因为要保证新老VC拥有同一个parentViewController，且参数中的viewController不能是系统中的container，比如不能是UINavigationController或者UITabbarController等。  <br />
所以如果你要自己写一个界面容器往往用不了appearence callbacks自动调用的特性，需要将此特性关闭，然后自己去精确控制appearance callbacks的调用时机。 <br />
那如何关闭appearance callbacks的自动传递的特性呢？在iOS 5.x中你需要覆盖<code>automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers</code>,然后返回NO,iOS6+中你需要覆盖 <code>shouldAutomaticallyForwardAppearanceMethods</code>方法并返回NO. <br />
手动传递的时候你并不能直接去调用child 的viewWillAppear或者viewDidAppear这些方法，而是需要使用 <code>beginAppearanceTransition:animated:</code>和<code>endAppearanceTransition</code>接口来间接触发那些appearance callbacks，且begin和end必须成对出现。 <br />
<code>[content beginAppearanceTransition:YES animated:animated]</code>触发content的viewWillAppear，<code>[content beginAppearanceTransition:NO animated:animated]</code>触发content的viewWillDisappear，和他们配套的[content endAppearanceTransition]分别触发viewDidAppear和viewDidDisappear。  (AppearanceTransition的这两个接口之前在苹果描述的文档中一开始还存在问题，因为文档中一开始说是iOS5不支持这两个接口，其实是支持的，后来苹果纠正了文档中的这个错误)。</p>

<h3 id="rotation-callbacks">三.rotation callbacks的传递</h3>
<p>也许在iPhone上很少要关心的屏幕旋转问题的，但是大屏幕的iPad上就不同了，很多时候你需要关心横竖屏。rotation callbacks 一般情况下只需要关心三个方法
<code>willRotateToInterfaceOrientation:duration:</code>在旋转开始前，此方法会被调用；<code>willAnimateRotationToInterfaceOrientation:duration:</code> 此方法的调用在旋转动画block的内部，也就是说在此方法中的代码会作为旋转animation block的一部分；<code>didRotateFromInterfaceOrientation:</code>此方法会在旋转结束时被调用。而作为view controller container 就要肩负起旋转的决策以及旋转的callbacks的传递的责任。</p>

<p>当使用框架的自动传递的特性的时候，作为容器的view controller 会自动
将这些方法传递给所有的child viewcontrollers， 有时候你可能不需要传递给所有的child viewcontroller，而只需要传递给正在显示的child viewcontroller，那么你就需要禁掉旋转回调自动传递的特性，和禁掉appearance callbacks自动传递的方式类似，需要覆盖相关方法并返回NO，在iOS5.x中，appearance callbacks和rotation callbacks禁掉是公用一个方法的就是 <code>automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers</code>，在iOS6之后分成两个独立的方法，旋转的则是 <code>shouldAutomaticallyForwardRotationMethods</code>。 <br />
旋转相关的除了上面的几个rotation callbacks方法外，还有一个十分重要的概念，就是一个view controller可以决定自己是否支持当前取向的旋转，这个东西在iOS6前后的实现方式还不一样，iOS6之前使用的方法是 <code>shouldAutorotateToInterfaceOrientation</code>，就是一个view controller覆盖此方法，根据传入的即将旋转的取向的参数，来决定是否旋转。而iOS6.0之后的实现则拆分成两个方法 <code>shouldAutorotate</code>和<code>supportedInterfaceOrientations</code>,前者决定再旋转的时候是否去根据<code>supportedInterfaceOrientations</code>所支持的取向来决定是否旋转，也就是说如果<code>shouldAutorotate</code>返回YES的时候，才会去调用<code>supportedInterfaceOrientations</code>检查当前view controller支持的取向，如果当前取向在支持的范围中，则进行旋转，如果不在则不旋转；而当<code>shouldAutorotate</code>返回NO的时候，则根本不会去管<code>supportedInterfaceOrientations</code>这个方法，反正是不会跟着设备旋转就是了。 <br />
而作为界面容器你要注意的就是你需要去检查你的child view controller，检查他们对横竖屏的支持情况，以便容器自己决策在横竖屏旋转时候是否支持当前的取向，和上面的callbacks传递的方向相比，这其实是一个反向的传递。</p>

<h3 id="section-1">四.创建自己的容器基类</h3>
<p>当你需要构建自己的Container View Controller的时候，每一个Container都会有一些相同的逻辑，如果你每一个都写一遍会存在很多重复代码，所以最好你创建一个Container基类，去实现容器都需要的逻辑。那到底有哪些逻辑是每一个Container都需要做的呢？关闭Appearance和Rotation相关方法的自动传递；当Container的Appearance和Rotation相关方法被调用时，需要将方法传递给相关的Child View Controller；以及当前Container是否支持旋转的决策逻辑等。下面为一个容器基类的示范:</p>

<pre><code>#import "ContainerBaseController.h"

@implementation ContainerBaseController

#pragma mark -
#pragma mark Overrides
//NS_DEPRECATED_IOS(5_0,6_0)
- (BOOL)automaticallyForwardAppearanceAndRotationMethodsToChildViewControllers{
return NO;
}

//NS_AVAILABLE_IOS(6_0)
- (BOOL)shouldAutomaticallyForwardAppearanceMethods{
    return NO;
}

//NS_AVAILABLE_IOS(6_0)
- (BOOL)shouldAutomaticallyForwardRotationMethods{
return NO;
}

- (void)viewWillAppear:(BOOL)animated{
    [super viewWillAppear:animated];

    NSArray *viewControllers = [self childViewControllersWithAppearanceCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
        [viewController beginAppearanceTransition:YES animated:animated];
    }
}

- (void)viewDidAppear:(BOOL)animated{
    [super viewDidAppear:animated];

    NSArray *viewControllers = [self childViewControllersWithAppearanceCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
        [viewController endAppearanceTransition];
    }
}

- (void)viewWillDisappear:(BOOL)animated{
    [super viewWillDisappear:animated];

    NSArray *viewControllers = [self childViewControllersWithAppearanceCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
        [viewController beginAppearanceTransition:NO animated:animated];
    }
}

- (void)viewDidDisappear:(BOOL)animated{
    [super viewDidDisappear:animated];

    NSArray *viewControllers = [self childViewControllersWithAppearanceCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
        [viewController endAppearanceTransition];
    }
}


- (void)willRotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration{
    [super willRotateToInterfaceOrientation:toInterfaceOrientation duration:duration];

    NSArray *viewControllers = [self childViewControllersWithRotationCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
        [viewController willRotateToInterfaceOrientation:toInterfaceOrientation duration:duration];

}
}

- (void)willAnimateRotationToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation duration:(NSTimeInterval)duration{
    [super willAnimateRotationToInterfaceOrientation:toInterfaceOrientation duration:duration];

    NSArray *viewControllers = [self childViewControllersWithRotationCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
            [viewController willAnimateRotationToInterfaceOrientation:toInterfaceOrientation duration:duration];
    }
}

- (void)didRotateFromInterfaceOrientation:(UIInterfaceOrientation)fromInterfaceOrientation{
    [super didRotateFromInterfaceOrientation:fromInterfaceOrientation];

    NSArray *viewControllers = [self childViewControllersWithRotationCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
        [viewController didRotateFromInterfaceOrientation:fromInterfaceOrientation];
    }
}

/*
 NS_AVAILABLE_IOS(6_0) 
 向下查看和旋转相关的ChildViewController的shouldAutorotate的值
 只有所有相关的子VC都支持Autorotate，才返回YES
 */
- (BOOL)shouldAutorotate{
    NSArray *viewControllers = [self childViewControllersWithRotationCallbackAutoForward];
    BOOL shouldAutorotate = YES;
    for (UIViewController *viewController in viewControllers) {
        shouldAutorotate = shouldAutorotate &amp;&amp;  [viewController shouldAutorotate];
    }

    return shouldAutorotate;
}

/*
 NS_AVAILABLE_IOS(6_0) 
 此方法会在设备旋转且shouldAutorotate返回YES的时候才会被触发
 根据对应的所有支持的取向来决定是否需要旋转
 作为容器，支持的取向还决定于自己的相关子ViewControllers
 */
- (NSUInteger)supportedInterfaceOrientations{
    NSUInteger supportedInterfaceOrientations = UIInterfaceOrientationMaskAll;

    NSArray *viewControllers = [self childViewControllersWithRotationCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
        supportedInterfaceOrientations = supportedInterfaceOrientations &amp; [viewController supportedInterfaceOrientations];
    }

    return supportedInterfaceOrientations;
}


/*
 NS_DEPRECATED_IOS(2_0, 6_0) 6.0以下，设备旋转时，此方法会被调用
 用来决定是否要旋转
 */
- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation{
    BOOL shouldAutorotate = YES;
    NSArray *viewControllers = [self childViewControllersWithRotationCallbackAutoForward];
    for (UIViewController *viewController in viewControllers) {
    shouldAutorotate = shouldAutorotate &amp;&amp;  [viewController shouldAutorotateToInterfaceOrientation:toInterfaceOrientation];
    }
    return shouldAutorotate;
}

#pragma mark -
#pragma mark 下面两个方法是在需要的情况下给基类覆盖用的，毕竟不是所有的容器都需要将相关方法传递给所有的childViewControllers
- (NSArray *)childViewControllersWithAppearanceCallbackAutoForward{
    return self.childViewControllers;
}

- (NSArray *)childViewControllersWithRotationCallbackAutoForward{
    return self.childViewControllers;
}

@end
</code></pre>

<h3 id="container">五.创建自己的Container</h3>
<p>####设计要点
创建一个Container，首先你得设计好Container View Controller的行为和公开的API，你可以好好参考UIKit中自带的一些Container的设计风格，比如UINaivgationController就是管理着一组Content View Controller的堆栈的Container,且正在显示的是栈顶的View Controller。</p>

<p>主要接口有View Controller的推入，此过程中viewController会和navigationController建立父子关系，并将viewController显示出来，如果animated是YES的话，则会有过场动画：</p>

<pre><code>- (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated
</code></pre>

<p>pop操作，移除栈顶的内容，会解除和navigationController的父子关系：</p>

<pre><code>- (UIViewController *)popViewControllerAnimated:(BOOL)animated;
</code></pre>

<p>当然关于pop还有一些其他的便捷接口，这里就不赘述了。</p>

<p>另外需要提供一些快捷的接口方便<strong>获取特定的Child View Controller</strong>，比如<code>topViewController</code>可以获取栈顶的View Controller。</p>

<p>另外如有必要，Container还需要留有<strong>delegate接口</strong>，便于通知外面Container的相关行为阶段，便于外部做出相关操作，比如UINaivgationController就会在即将要push一个新的View Controller，已经push了一个新的View Controller等时机留有delegate方法。</p>

<p>还有一个需要考虑的问题就是直接或者间接的Child View Controller如何快速的<strong>检索</strong>到相应的Container呢？一般Container在实现的时候就需要考虑此问题并提供相应的接口，实现的方法一般就是实现一个UIViewController的Category，比如UINavigationController，在某个View Controller中访问其navigationController属性，会向上遍历，直到找到最近的类型为UINavigationController的祖先，如果找不到则为nil：</p>

<pre><code>@interface UIViewController (UINavigationControllerItem)
...
@property(nonatomic,readonly,retain) UINavigationController *navigationController;

@end
</code></pre>

<p>####实现一个简单的模态窗口Container <br />
模态展示 则至少存在present，dismiss的接口，以及获取模态View Controller的属性</p>

<pre><code>#import &lt;UIKit/UIKit.h&gt;
#import "ContainerBaseController.h"

@interface SimpleModalContainerController : ContainerBaseController

@property (nonatomic, readonly) UIViewController *simpleModalViewController;

- (void)presentSimpleModalViewController:(UIViewController *)viewControllerToPresent
                            animated:(BOOL)animated;

- (void)dismissSimpleModalViewControllerAnimated:(BOOL)animated;

@end

//实现如下
#import "SimpleModalContainerController.h"

@interface SimpleModalContainerController ()
@property (nonatomic, readwrite) UIViewController *simpleModalViewController;
@property (nonatomic, strong) UIButton *backgroundButton;
@end

@implementation SimpleModalContainerController

- (void)buttonTapped:(id)sender{
    [self dismissSimpleModalViewControllerAnimated:YES];
}

- (UIButton *)backgroundButton{
    if (!_backgroundButton) {
        _backgroundButton = [UIButton buttonWithType:UIButtonTypeCustom];
        _backgroundButton.backgroundColor = [UIColor blackColor];
        _backgroundButton.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;
        _backgroundButton.alpha = 0.3;
        [_backgroundButton addTarget:self action:@selector(buttonTapped:) forControlEvents:UIControlEventTouchUpInside];

    }
    _backgroundButton.frame = self.view.bounds;
    return _backgroundButton;
}

- (void)presentSimpleModalViewController:(UIViewController *)viewControllerToPresent
                            animated:(BOOL)animated{
    if (!self.simpleModalViewController &amp;&amp; viewControllerToPresent) {
        self.simpleModalViewController = viewControllerToPresent;
    
        [self addChildViewController:viewControllerToPresent];
    
        [viewControllerToPresent beginAppearanceTransition:YES animated:animated];
    
        [self.view addSubview:self.backgroundButton];
    
        viewControllerToPresent.view.center = CGPointMake(CGRectGetWidth(self.view.bounds) / 2.0, CGRectGetHeight(self.view.bounds) / 2.0);
        [self.view addSubview:viewControllerToPresent.view];
    
        if (animated) {
            viewControllerToPresent.view.alpha = 0;
            self.backgroundButton.alpha = 0;
        
            [UIView animateWithDuration:0.3 animations:^{
                viewControllerToPresent.view.alpha = 1;
                self.backgroundButton.alpha = 0.3;
            } completion:^(BOOL finished) {
                [viewControllerToPresent endAppearanceTransition];
                [viewControllerToPresent didMoveToParentViewController:self];
            }];
        } else {
            self.backgroundButton.alpha = 0.3;
            [viewControllerToPresent endAppearanceTransition];
            [viewControllerToPresent didMoveToParentViewController:self];
        }
    
    }
}

- (void)dismissSimpleModalViewControllerAnimated:(BOOL)animated{
    if (self.simpleModalViewController) {
        [self.simpleModalViewController willMoveToParentViewController:nil];
        [self.simpleModalViewController beginAppearanceTransition:NO animated:animated];
    
        if (animated) {
            [UIView animateWithDuration:0.3 animations:^{
                self.backgroundButton.alpha = 0;
                self.simpleModalViewController.view.alpha = 0 ;
            } completion:^(BOOL finished) {
                [self.backgroundButton removeFromSuperview];
            
                [self.simpleModalViewController.view removeFromSuperview];
                self.simpleModalViewController.view.alpha = 1.0;
                [self.simpleModalViewController endAppearanceTransition];
                [self.simpleModalViewController removeFromParentViewController];
                self.simpleModalViewController = nil;
            }];
        } else {
            [self.backgroundButton removeFromSuperview];

            [self.simpleModalViewController.view removeFromSuperview];
            self.simpleModalViewController.view.alpha = 1.0;
            [self.simpleModalViewController endAppearanceTransition];
            [self.simpleModalViewController removeFromParentViewController];
            self.simpleModalViewController = nil;
        }
    }
}

@end
</code></pre>

<p>UIViewController的Category用于Child View Controller 获取上层的SimpleModalContainerController</p>

<pre><code>@interface UIViewController (SimpleModalContainerController)

@property (nonatomic, readonly) SimpleModalContainerController *simpleModalContainerController;

@end

@implementation UIViewController (SimpleModalContainerController)

- (SimpleModalContainerController *)simpleModalContainerController{
    for (UIViewController *viewController = self.parentViewController; viewController != nil; viewController = viewController.parentViewController) {
        if ([viewController isKindOfClass:[SimpleModalContainerController class]]) {
            return (SimpleModalContainerController *)viewController;
        }
    }
    return nil;
}

@end
</code></pre>

]]></content:encoded>
    </item>
    
    <item>
      <title>谈谈objc公用库</title>
      <link href="http://geeklu.com/2014/02/objc-lib/"/>
      <pubDate>2014-02-10T00:00:00+08:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2014/02/objc-lib</guid>
      <content:encoded><![CDATA[<h2 id="section">一.概述</h2>
<p>objc公用库的使用场景还是比较常见的，iOS SDK本身就是公用库的集合；一些开放平台为了方便开发者开发第三方的app，提供相应平台的sdk；还有一个场景就是比较大的公司一般会有多个甚至几十个app，各个app之间势必会有重复的逻辑，为了 “提升效率”“安全性” 或者业务指标，会推一些公用的库供内部各个app使用。 <br />
公用库本质上就是一些可重用逻辑的集合，是“分而治之”的一种途径，其出现的形式可以是源码亦或是二进制。 <br />
公用库也需要理清自己的依赖关系，比如依赖系统SDK的哪些库的哪些接口（决定了公用库适用的系统版本），依赖哪些第三方的库。不过你想把一个东西拿出去给别人用，那你就得想方设法去减少不必要的依赖。 <br />
作为一个公用库的开发者，提供公用库给别人使用时，需要站在使用者的角度去思考问题，公用库的接口以及接入使用的繁简体现了公用库作者的职业道德和素养。</p>

<h2 id="section-1">二.设计与实现</h2>
<p>第一步当然是明确公用库的目标，要做什么，不做什么，一二三四列出来，并在后继的实现中最大可能地坚持目标原则。  <br />
项目的构建也有几种选择：</p>

<ul>
  <li>使用XCode的”Cocoa Touch Static Library”项目模板新建项目，target为一个静态库</li>
  <li>安装 <a href="https://github.com/kstenerud/iOS-Universal-Framework">iOS Universal Framework</a> ,然后在XCode中通过其提供的”Static iOS Framework”项目模板新建项目，其target为framework库</li>
</ul>

<p>另外你可以在上面的基础上，通过<a href="http://cocoapods.org/">cocoapods</a>来管理你自己的公用库的依赖。</p>

<p>在实现的时候，公用库自身的源码全都放到某个目录中或者其子目录中(是指那些可以直接拷贝出去使用的源码，不包括自身编译所依赖的文件，比如prefix.pch)。 <br />
头文件只暴漏那些必须的，在实现库的时候能够在实现文件中进行引入的的则在实现文件中进行引入，如果在需要暴漏的头文件中引入另一个头文件，那么这另一个头文件也必须要暴漏出来。   <br />
另一个常见的问题便是接口的方法声明不遵循objc的语言规范，给人以山寨的感觉。还是建议公用库的实现最好有一个当前语言的老手带着做，熟悉当前语言的规范和常用的范式，比如何时使用delegate，何时使用block。 <br />
还有就是在实现的时候尽可能少地引入第三方的依赖，如果确实需要引入，那么编译的时候千万别把公用库自身依赖的第三方的内容当成自己的一部分，如果你很变态，硬要把第三方的内容搞成自己的一部分，那么你至少得修改这些依赖的相关类的类名，静态变量名，如果是category，还得修改其方法名。    <br />
最后就是你得坚持良好的注释和文档 ，某个方法 如有特殊的需要注意的点，则需要注释说明，你还得提供一个README文件，用于描述当前库的目的，以及各个接口的使用范例。</p>

<h2 id="section-2">三.分发与集成</h2>
<p>其实在公用库构建的初期，你就得想好分发的方式。一种好的分发方式可以大大降低公用库集成使用的成本。 <br />
一个公用库要给别人用，无非就两种形式：源码或者二进制格式（额外提供头文件，资源文件），源码的形式，方便使用者进行调试，二进制格式则适用于那些不方便公开源码的公用库。</p>

<ul>
  <li>先谈谈源码的形式，源码一般放在某个版本控制库中
    <ul>
      <li>在以前很多人就直接下载下来将相关类拷贝进自己的工程中，然后直接使用，这样的坏处就是没法明确知道此公用库的版本以及此库作者做了更新后，你还得手动拷贝一次，比较麻烦。</li>
      <li>后来就开始用git的submodule，主工程无需将某个公用库的源码放到自己的git库中了，而且三方库可以方便的进行更新切换分支等操作，这种情况下最好是将主工程依赖此三方库项目编译出来的target，比如静态库，这样当公用库有增删文件的时候，无需修改主工程项目文件。</li>
      <li>最近我比较推荐的就是cocoapods的方式了，它的主要优点就是依赖关系的管理，当然其本质上也是将公用库编译成静态库，然后使得主工程依赖此静态库。</li>
    </ul>
  </li>
  <li>二进制的形式需要谈的东西还是比较多的，二进制一般有两种方式
    <ul>
      <li>一种是简单的静态库，也就是常见的 xxx.a 文件, 只不过真正使用的时候需要提供头文件或者资源文件，一般资源文件都是以bundle的形式提供。XCode中默认提供的就是这种方式，只不过你创建公用库项目的时候编译出来静态库只支持特定的一种硬件架构体系，如果你想生成一个Universal的静态库的话，那么你得通过工具来将多个静态库进行合并。</li>
      <li>另一种便是framework的方式，此方式XCode默认并不支持。你在iOS开发的过程中应该接触过不少framework库，这种库都是系统自带的库，供系统中运行的所有app共享使用。framework库的好处就是不但可以包含二进制文件，还可以包含头文件，资源文件等，甚至可以支持多个版本。各个app所使用的自己的公用库，最终都需要link进可执行文件件的，所以本质上还是一个静态库。所以有一些第三方的方案比如<a href="https://github.com/kstenerud/iOS-Universal-Framework">iOS Universal Framework</a>，能够帮助你使用XCode来编译出framework库，当然其中还是有不少坑，比如XCode并不识别framework中的资源文件所以有了Embedded Framework的方案，虽然framework最终只是一个bundle（一个文件夹，里面按照规定的目录结构方式文件），但是对XCode而言这样的target还是有真假（Real／Fake）之分，只有真的情况下XCode主工程在添加依赖的时候才能够选择此公用库项目的framework涨的target。</li>
      <li>cocoapods也是支持管理二进制格式的，在podspec中通过vendored_frameworks或者vendored_libraries来指定你需要分发的库</li>
    </ul>
  </li>
</ul>

<p>当然不管你以何种方式分发你的公用库，你都得明确声明此公用库适用的系统版本，依赖哪些系统SDK的框架或者静态库，依赖哪些第三方的库以及对应的版本，这是对自己负责也是对别人负责。 <br />
在使用公用库的时候，XCode都是通过header search path来寻找静态库的头文件的，通过framework search path来寻找framework的，当使用cocoapods来管理的时候，这些环境变量的设置都是自动帮你完成的，在其生成的xcconfig文件中。</p>

<h2 id="section-3">四.和库相关的几个命令</h2>
<p>下面几个命令都是和二进制库相关的，这些二进制文件可以叫做对象文件，在Mac或者iOS平台中用的都是<a href="http://zh.wikipedia.org/wiki/Mach-O">Mach-O</a>(Mach Object)，所以这些命令其实都是读取或者操作Mach Object的，你可以通过<code>man</code>来查看相应的详情用户手册。</p>

<ul>
  <li>nm <br />
 	display name list (symbol table)，其实就是把对象文件中的相关符号标识都列出来</li>
  <li>otool <br />
 	otool，顾名思义就是object tool，比其nm来说，其功能更强大，可以查看对象文件的方方面面，比如展示对象文件的Mach Header，用到了哪些共享库（shared libraries），或者数据段内容等。</li>
  <li>lipo  <br />
 	create or operate on universal files，此命令主要是帮你查看或者创建支付多平台的静态库的。比如将两台不同平台的静态进行合并。</li>
</ul>

]]></content:encoded>
    </item>
    
    <item>
      <title>Git fork workflow</title>
      <link href="http://geeklu.com/2013/06/git-fork-workflow/"/>
      <pubDate>2013-06-23T00:00:00+08:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2013/06/git-fork-workflow</guid>
      <content:encoded><![CDATA[<p>1.Fork   <br />
2.Add upstream repo</p>

<pre><code>git clone &lt;forked repo url&gt;
cd &lt;repo foder&gt;
git remote add upstream &lt;origin repo url&gt;
</code></pre>

<p>3.Fetch upsteam and merge</p>

<pre><code>git checkout master
git fetch upstream
git merge upstream/master
git push origin master
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>Cocoapods 101</title>
      <link href="http://geeklu.com/2013/06/cocoapods-101/"/>
      <pubDate>2013-06-23T00:00:00+08:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2013/06/cocoapods-101</guid>
      <content:encoded><![CDATA[<p><img width="140" height="140" src="http://ww1.sinaimg.cn/bmiddle/65cc0af7jw1e5wzbyfdkgj20bo0bogm8.jpg" /></p>

<p>###一.cocoapods介绍
在开发iOS的程序的时候，经常会用到第三方的库，一般的做法就是直接将其源码拷贝到自己的项目中，或者将其静态库拷贝到项目中进行使用。当这个三方库的版本更新了，还需要重新进行拷贝复制，非常不方便，且库与库之间的依赖也不好管理，cocoapods的出现便是解决这一问题的。cocoapods是一个ruby实现的objc三方库依赖管理工具，可以看得出，cocoapods在很多地方借鉴了ruby的包管理工具gem。
每一个三方库的版本在cocoapods中叫做一个pod，每一个pod对应一个描述文件，这个描述文件叫做podspec文件，其中描述了这个pod的名称，版本，许可证，主页，作者，源码库位置，平台，所依赖的其他三方库以及系统的framework，是否arc等信息。cocoapods官方默认支持的所有podspec都放在github上，地址为 <a href="https://github.com/CocoaPods/Specs">https://github.com/CocoaPods/Specs</a>，你也可以加入自定义的podspec库，以引入官方库中没有的podspec，添加自定义podspec库的方式为</p>

<pre><code>$ pod repo add &lt;repo name&gt; &lt;git repo url&gt;
</code></pre>

<p>执行上条命令之后，pod便会将自定义的库clone到 <code>~/.cocoapods/&lt;repo name&gt;</code></p>

<p>###二.cocoapods安装
cocoapods是使用ruby写的，可以通过gem进行安装，所以第一步你需要整好自己的ruby环境，安装cocoapods。在Mac上系统默认已经安装了ruby，不过版本比较老了，所以在实际使用中还是会自己安装ruby的。而且为了方便日后切换ruby的版本，一般会通过ruby的管理工具进行ruby的安装，很多人喜欢使用RVM，而我更喜欢轻量级的rbenv,首先得安装好XCode及其命令行工具，这样就准备好了Mac上的编译环境。
然后安装rbenv,其实就是讲rbenv的库clone到本地，以及相应的插件</p>

<pre><code>git clone git://github.com/sstephenson/rbenv.git ~/.rbenv
git clone git://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
git clone git://github.com/sstephenson/rbenv-gem-rehash.git ~/.rbenv/plugins/rbenv-gem-rehash
</code></pre>

<p>假设你命令行使用了zsh，如果没有使用则推荐你使用，讲rbenv的path加入到环境变量中</p>

<pre><code>echo 'export PATH="$HOME/.rbenv/bin:$PATH"' &gt;&gt; $HOME/.zshrc
echo 'eval "$(rbenv init -)"' &gt;&gt; $HOME/.zshrc
</code></pre>

<p>准备好rbenv后，则准备安装ruby版本，</p>

<pre><code>rbenv install 2.0.0-p195
rbenv global 2.0.0-p195
</code></pre>

<p>安装好ruby后，准备安装cocoapods，首先重新设置gem的源地址，因为国外的源地址速度太慢，我们使用淘宝的镜像源</p>

<pre><code>gem sources -a http://ruby.taobao.org/
gem sources -l #查看现在所有的源地址
gem sources --remove http://rubygems.org/ #移除默认的源地址

gem install cocoapods #安装cocoapods
</code></pre>

<h3 id="cocoapods">三.cocoapods使用</h3>
<p>#####1.创建一个项目，比如创建一个名为podtest的项目
#####2.在项目的根目录中创建一个名为’Podfile’的文件，在此文件中加入相应的设置</p>

<pre><code>platform :ios, '5.0'
pod 'AFNetworking' #####3.在项目根目录中运行`pod install`，得到如下输出

➔ pod install
Setting up CocoaPods master repo

CocoaPods 0.21.0.rc1 is available.

Setup completed (read-only access)
Analyzing dependencies

CocoaPods 0.21.0.rc1 is available.

Downloading dependencies
Installing AFNetworking (1.3.1)
Generating Pods project
Integrating client project

[!] From now on use `podtest.xcworkspace`.
</code></pre>

<p>这个时候在你的home目录中多了一个.cocoapods的目录，且此目录下有一个master的目录，这里便是自动clone出来的官方的podspec库。</p>

<p>#####4.这个时候已经生成了一个XCode的workspace文件，你可以打开workspace
你会发现cocoapods会将所有的三方库放在一个单独的名为Pods的项目中进行维护，这个Pods的项目将所有的三方库打包成一个单独的静态库，供主项目使用，至于三方库的资源文件，则提供了一个拷贝脚本，供主项目使用<code>Pods-resources.sh</code></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Discourse的自动化部署</title>
      <link href="http://geeklu.com/2013/05/discourse-install-guide/"/>
      <pubDate>2013-05-25T00:00:00+08:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2013/05/discourse-install-guide</guid>
      <content:encoded><![CDATA[<blockquote>
  <p>大家可以到这里来讨论 Discourse的安装  <a href="http://www.mydiscourse.org/t/discourse/27">http://www.mydiscourse.org/t/discourse/27</a></p>
</blockquote>

<p><a href="http://discourse.org/">Discourse</a>是一个开源的论坛程序，由Stack Overflow的联合创始人之一Jeff Atwood在离开Stack Overflow后组队创建。他们的目标很宏伟，就是创建一个面向未来十年的论坛程序。具体的一些论坛的特性可以到其官网上查看，这里主要讨论一些其技术相关的东西。
Discourse的源码托管在github上,<a href="https://github.com/discourse/discourse">https://github.com/discourse/discourse</a>，使用了以下一些相关技术：</p>

<ul>
  <li>Ruby on Rails ，Discourse的后端是一个rails的app,RESTful的api，返回JSON格式的数据</li>
  <li>Ember.js ，Discourse的前端是一个Ember.js的app，和rails的api进行交互，他们使用这个Ember.js的原因可以参考这篇博文<a href="http://eviltrout.com/2013/02/10/why-discourse-uses-emberjs.html">http://eviltrout.com/2013/02/10/why-discourse-uses-emberjs.html</a>,此博主在Discourse项目中主要担任前端开发工作，他的观点就是如果一个web应用是一个强交互应用的话，那么使用Client MVC的js框架将利大于弊</li>
  <li>PostgreSQL ， 主要的数据都使用PostgreSQL进行存储，这个具有学院派风格的数据库经过多年的发展，稳定性，性能都非常不错，功能全面也是其一大特色。</li>
  <li>Redis ，使用Redis这个kv数据库用于任务队列等功能</li>
</ul>

<p>如果你想使用Discourse搭建一个论坛，那么一个虚拟主机（VPS）是必不可少的了。本文所使用的主机是在Digital Ocean上申请的，机房选择的是旧金山，国内的访问速度还可以，我是比较熟悉Debian系（比如Debian，Ubuntu…）的Linux发行版本，安装软件直接apt-get解决，非常的方便。所以就选了Debian 7.0 x32 Server，512MB Ram，20GB SSD Disk，不过Discourse官方建议的最低内存是1G。  <br />
<br />
应用的部署使用了一个ruby写的叫做<a href="https://github.com/capistrano/capistrano">Capistrano</a>的工具，它是一个远程自动部署的工具，支持插件比如这次就使用了一个Capistrano的rbenv插件。  <br />
Capistrano的使用中涉及到两方：一方是客户端，也就是发起运行Capistrano的一方，Capistrano的配置文件都在客户端；另一方是服务器端，也就是最终应用部署的目标容器。我们在客户端中配置好Capistrano以及发布的脚本，然后运行之，Capistrano便会根据脚本通过ssh连接到服务器上进行部署的各项工作，这些步骤无需我们直接操作，我们只需要看着命令行中输出的log便可。</p>

<p>###一.服务器端的各项准备工作</p>

<p>创建好虚拟主机后服务器端的一些工作</p>

<p>####0.准备工作
更新系统：</p>

<pre><code>apt-get update
apt-get upgrade
apt-get install vim #默认的vi不太好用,你也可以选择别的编辑器比如nano
</code></pre>

<p>确认下hostname</p>

<pre><code>vi /etc/hosts #比如 127.0.0.1       localhost mydiscourse.org
</code></pre>

<p>####1.创建交换区
有些虚拟机提供商可能默认就创建好交换区了，你可以通过free命令来查看，如果free的结果中看到类似如下这一行的时候，说明已经存在swap分区了</p>

<pre><code>	Swap:       524284      23968     500316
</code></pre>

<p>swap分区的作用就是当物理内存不够用的时候，系统将物理内存中长时间没有活动的部分转移到swap分区中，以腾出更多的内存供应用使用。当某个程序需要用到swap分区中的内容的时候，在从swap分区中转移出来。
Digital Ocean默认是没有帮你创建好交换分区的，创建的方式如下：</p>

<pre><code>sudo dd if=/dev/zero of=/swapfile bs=1024 count=512k
sudo mkswap /swapfile
sudo swapon /swapfile
</code></pre>

<p>然后使用vim编辑/etc/fstab，添加下面这行</p>

<pre><code>/swapfile       none    swap    sw      0       0
</code></pre>

<p>为了安全，得修改swapfile的权限</p>

<pre><code>sudo chown root:root /swapfile
sudo chmod 0600 /swapfile
</code></pre>

<p>最后再次通过free命令确认下交换分区是否创建成功。</p>

<p>####2.创建发布用户
在Linux中，用户管理是一个和系统安全息息相关的问题，所以控制好用户的权限非常的重要。
首先在服务器上需要创建一个专门用于Capistrano发布的账户，我们叫他deploy user,并且将账户的登录方式限制为公私钥认证的方式，禁掉密码认证的登录方式（甚至可以附带关闭root ssh登录系统的权限），这些设置都是在sshd的配置文件中进行设置。
一开始是root登录，这时你需要增加一个deploy user，我们就假设名字为 <code>apps</code></p>

<pre><code>adduser apps #增加一个用户 apps
adduser apps sudo #将apps用户加到sudo组，使其可以使用sudo
</code></pre>

<p>这个时候你可以在客户端通过apps用户进行登录了
要设置ssh验证方式，首先得在客户端也就是本机（desktop）上生成密钥对（如果你之前已经有了可以跳过此步）</p>

<pre><code>ssh-keygen
</code></pre>

<p>这个时候会在~/.ssh 目录下生成了两个文件 id_rsa 和 id_rsa.pub，前者为私有，后者为公钥，你需要将公钥内容加到服务器端对应用户的 <code>~/.ssh/authorized_keys</code> 文件中，如果authorized_keys不存在则你需要创建一下。
然后为了安全性 设置下相关目录的权限</p>

<pre><code>chown -R apps:apps .ssh
chmod 700 .ssh
chmod 600 .ssh/authorized_keys
</code></pre>

<p>这个时候你可以从客户端直接ssh连 过去而不用输入用户密码了，假设这个时候你以apps登录下，我们再把密码验证登录验证的方式关掉。</p>

<pre><code>#设置成 PasswordAuthentication no	以及 PermitRootLogin no
sudo vi /etc/ssh/sshd_config

#重启 sshd服务
sudo service ssh restart 
</code></pre>

<p>####3.安装必要的软件</p>

<pre><code>#编译ruby所需的基础库
sudo apt-get install build-essential openssl libreadline6 libreadline6-dev \
         curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-dev \
         sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev libgdbm-dev \
         ncurses-dev automake libtool bison subversion pkg-config libffi-dev
#安装nginx
sudo apt-get install nginx
#安装PostgreSQL redis
sudo apt-get install postgresql-9.1 postgresql-contrib-9.1 redis-server \
                     libxml2-dev libxslt-dev libpq-dev make g++
</code></pre>

<p>创建好数据的角色和数据库</p>

<pre><code>sudo -u postgres createuser apps -s -P
createdb -U apps discourse_production
</code></pre>

<p>由于Discourse有邮件发送的需求，如果你想使用系统本身来发邮件，那么你还得安装sendmail</p>

<pre><code>apt-get install sendmail     &lt;br&gt; ###二.客户端的工作
</code></pre>

<p>####1.客户端安装基础软件
安装git，如果你是使用Linux那么直接使用相关的包管理软件进行安装，如果你使用的是Mac那么可以使用macprot或者brew这些第三方的包管理软件进行安装。当然如果你要使用源码编译的方式安装也是可以的。
安装ruby，你可以直接安装（包管理软件安装或者源码编译），也可以通过ruby版本管理的软件进行间接安装，比如rvm，rbenv。我这里选择了rbenv。
如果你是Linux你得确保编译所需的软件包都安装就绪</p>

<pre><code>sudo apt-get install build-essential openssl libreadline6 libreadline6-dev \
         curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-dev \
         sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev libgdbm-dev \
         ncurses-dev automake libtool bison subversion pkg-config libffi-dev
</code></pre>

<p>如果你是Mac，那么XCode以及XCode命令行工具你得安装就位。</p>

<p>安装rbenv以及通过rbenv安装ruby</p>

<pre><code>#安装rbenv
git clone git://github.com/sstephenson/rbenv.git ~/.rbenv
echo 'export PATH="$HOME/.rbenv/bin:$PATH"' &gt;&gt; ~/.bash_profile
echo 'eval "$(rbenv init -)"' &gt;&gt; ~/.bash_profile
exec $SHELL -l

#安装rbenv的ruby-build插件，方便ruby版本的安装
git clone https://github.com/sstephenson/ruby-build.git ~/.rbenv/plugins/ruby-build
#安装rbenv的rehash插件，安装了新的gem后再也不用运行rbenv rehash了:)
git clone https://github.com/sstephenson/rbenv-gem-rehash.git ~/.rbenv/plugins/rbenv-gem-rehash

#安装ruby-2.0.0-p195以及bundler
rbenv install 2.0.0-p195; 
rbenv global 2.0.0-p195
gem install bundler
</code></pre>

<p>####2.git库的相关操作
如果你想自己做一些自定义的开发工作或者想为discourse这个开源项目贡献自己的代码，那么你去注册一个github的账号是必不可少的了。
然后从 <a href="https://github.com/discourse/discourse">https://github.com/discourse/discourse</a> fork一个git库出来，比如我fork出来的地址为 <a href="https://github.com/kejinlu/discourse">https://github.com/kejinlu/discourse</a></p>

<pre><code>#克隆远程库到本地
git clone git@github.com:kejinlu/discourse.git
cd discourse
#增加上游库,以便将上游的更新合并过来
git remote add upstream git@github.com:discourse/discourse.git 
</code></pre>

<p>####3.准备Discourse生产环境所需的配置文件</p>

<p>#####config/database.yml
数据库的配置文件，主要配置数据库的用户名密码，以及相关hostname</p>

<pre><code>cp database.yml.production-sample config/database.yml 
#然后对用户名密码以及对生产环境对应的host_names进行修改
vi config/database.yml 
</code></pre>

<p>#####config/redis.yml
配置文件可以直接使用样例</p>

<pre><code>cp redis.yml.sample redis.yml #使用样例的配置即可，无需修改
</code></pre>

<p>#####environments/production.rb
次配置文件主要需要修改就是邮件发送的配置，如果你不想使用操作系统中的sendmail进行发送邮件,你可以选择第三方的smtp服务，
比如我就是使用gmail的smtp进行发送的，相关配置如下：</p>

<pre><code>config.action_mailer.delivery_method = :smtp
config.action_mailer.perform_deliveries = true
config.action_mailer.raise_delivery_errors = true
config.action_mailer.smtp_settings = {
 :address              =&gt; "smtp.gmail.com",
 :port                 =&gt; 587,
 :domain               =&gt; 'mail.google.com',
 :user_name            =&gt; 'info.mydiscourse@gmail.com',
 :password             =&gt; 'xxxxxxxx',
 :authentication       =&gt; 'plain',
 :enable_starttls_auto =&gt; true  }
 
 #config.action_mailer.delivery_method = :sendmail
 #config.action_mailer.sendmail_settings = {arguments: '-i'}
</code></pre>

<p>#####initializers/secret_token.rb
这个文件是rails要用的，默认就存在了，只不过用于开发环境的，你需要生成一个新的secret并对这个文件进行修改</p>

<pre><code>bundle exec rake secret
</code></pre>

<p>将生成的字符串用到<code>initializers/secret_token.rb</code>文件中</p>

<p>最后这个文件除了注释掉的只剩下一行</p>

<pre><code>Discourse::Application.config.secret_token = "你生成的token贴到这里"
</code></pre>

<p>#####config/thin.yml
是用于thin的配置文件，</p>

<pre><code>cp config/thin.yml.sample config/thin.yml
</code></pre>

<p>在config/thin.yml最后加上一行</p>

<pre><code>onebyone: true
</code></pre>

<p>当然你也可以自己设置server的数量，一个server在运行的时候对应一个thin的进程，如果你的内存有线可以适当的减少server的数量，比如我设置成了2</p>

<pre><code>---
chdir: /home/apps/discourse/current
environment: production
address: 0.0.0.0
port: 3000
timeout: 30
log: /home/apps/discourse/shared/log/thin.log
pid: /home/apps/discourse/shared/pids/thin.pid
socket: /home/apps/discourse/shared/sockets/thin.sock
max_conns: 1024
max_persistent_conns: 100
require: []
wait: 30
servers: 2
daemonize: true
onebyone: true
</code></pre>

<p>#####config/nginx.conf</p>

<pre><code>cp config/nginx.conf.sample config/nginx.conf
</code></pre>

<p>这是nginx的配置文件，下面是我的配置，upstream里面内容和thin的配置对应,还要记得修改server_name以及location的root的位置</p>

<pre><code>upstream discourse {
  server unix:///home/apps/discourse/shared/sockets/thin.0.sock;
  server unix:///home/apps/discourse/shared/sockets/thin.1.sock;
}

server {

  listen 80;
  gzip on;
  gzip_min_length 1000;
  gzip_types application/json text/css application/x-javascript;

  server_name mydiscourse.org;

  sendfile on;

  keepalive_timeout 65;

  location / {
    root /home/apps/discourse/current/public;

    location ~ ^/t\/[0-9]+\/[0-9]+\/avatar {
      expires 1d;
      add_header Cache-Control public;
      add_header ETag "";
    }

    location ~ ^/assets/ {
      expires 1y;
      add_header Cache-Control public;
      add_header ETag "";
      break;
    }

    proxy_set_header  X-Real-IP  $remote_addr;
    proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header  X-Forwarded-Proto $scheme;
    proxy_set_header  Host $http_host;


    # If the file exists as a static file serve it directly without
    # running all the other rewite tests on it
    if (-f $request_filename) {
      break;
    }

    if (!-f $request_filename) {
      proxy_pass http://discourse;
      break;
    }

  }

}
</code></pre>

<p>由于上面的一些配置中涉及到一些敏感信息，你不不能将其放到public的库中，要不放到私有库中，要么将这些敏感文件加入git的ignore。如果将上述的文件加入ignore的话，那么在下面的deploy脚本中需要将本地的配置在部署的过程中拷贝到目标服务器中，作为生产环境的配置文件，如果你把正式的配置文件都放到了私有的库中，那么这些配置文件其实就没有必要从客户端再拷贝了，下文的deploy.rb脚本中就有从本地拷贝这些配置的过程。</p>

<p>####4.配置Capistrano</p>

<p>往Gemfile中加入两行</p>

<pre><code>gem 'capistrano', require: nil
gem 'capistrano-rbenv', require: nil
</code></pre>

<p>增加Capfile</p>

<pre><code>cp Capfile.sample Capfile
</code></pre>

<p>创建config/deploy.rb</p>

<pre><code># Require the necessary Capistrano recipes
require 'capistrano-rbenv'
require 'bundler/capistrano'
require 'sidekiq/capistrano'

# Repository settings, forked to an outside copy
set :repository, 'git://github.com/kejinlu/discourse.git'
set :deploy_via, :remote_cache
set :branch, fetch(:branch, 'master')
set :scm, :git

ssh_options[:keys] = [File.join(ENV["HOME"], ".ssh", "id_rsa")]
ssh_options[:forward_agent] = true

# General Settings
set :deploy_type, :deploy
default_run_options[:pty] = true


# Server Settings
set :user, 'apps'
set :use_sudo, false
set :rails_env, :production
set :rbenv_ruby_version, '2.0.0-p195'

role :app, 'mydiscourse.org', primary: true
role :db,  'mydiscourse.org', primary: true
role :web, 'mydiscourse.org', primary: true

# Application Settings
set :application, 'discourse'
set :deploy_to, "/home/#{user}/#{application}"

# Keep your bundle up to date!
#after "deploy:setup" do
#  run "cd #{current_path} &amp;&amp; bundle install"
#end

namespace :deploy do
  # Tasks to start, stop and restart thin. This takes Discourse's
  # recommendation of changing the RUBY_GC_MALLOC_LIMIT.
  desc 'Start thin servers'
  task :start, :roles =&gt; :app, :except =&gt; { :no_release =&gt; true } do
    run "cd #{current_path} &amp;&amp; RUBY_GC_MALLOC_LIMIT=90000000 bundle exec thin -C config/thin.yml start", :pty =&gt; false
  end

  desc 'Stop thin servers'
  task :stop, :roles =&gt; :app, :except =&gt; { :no_release =&gt; true } do
    run "cd #{current_path} &amp;&amp; bundle exec thin -C config/thin.yml stop"
  end

  desc 'Restart thin servers'
  task :restart, :roles =&gt; :app, :except =&gt; { :no_release =&gt; true } do
    run "cd #{current_path} &amp;&amp; RUBY_GC_MALLOC_LIMIT=90000000 bundle exec thin -C config/thin.yml restart"
  end

  # Sets up several shared directories for configuration and thin's sockets,
  # as well as uploading your sensitive configuration files to the serer.
  # The uploaded files are ones I've removed from version control since my
  # project is public. This task also symlinks the nginx configuration so, if
  # you change that, re-run this task.
  task :setup_config, roles: :app do
    run  "mkdir -p #{shared_path}/config/initializers"
    run  "mkdir -p #{shared_path}/config/environments"
    run  "mkdir -p #{shared_path}/sockets"
    put  File.read("config/database.yml"), "#{shared_path}/config/database.yml"
    put  File.read("config/redis.yml"), "#{shared_path}/config/redis.yml"
    put  File.read("config/environments/production.rb"), "#{shared_path}/config/environments/production.rb"
    put  File.read("config/initializers/secret_token.rb"), "#{shared_path}/config/initializers/secret_token.rb"
    put  File.read("config/thin.yml"), "#{shared_path}/config/thin.yml"
    put  File.read("config/nginx.conf"), "#{shared_path}/config/nginx.conf"
    sudo "ln -nfs #{shared_path}/config/nginx.conf /etc/nginx/sites-enabled/#{application}"
    puts "Now edit the config files in #{shared_path}."
  end

  # Symlinks all of your uploaded configuration files to where they should be.
  task :symlink_config, roles: :app do
    run  "ln -nfs #{shared_path}/config/database.yml #{release_path}/config/database.yml"
    run  "ln -nfs #{shared_path}/config/newrelic.yml #{release_path}/config/newrelic.yml"
    run  "ln -nfs #{shared_path}/config/redis.yml #{release_path}/config/redis.yml"
    run  "ln -nfs #{shared_path}/config/environments/production.rb #{release_path}/config/environments/production.rb"
    run  "ln -nfs #{shared_path}/config/initializers/secret_token.rb #{release_path}/config/initializers/secret_token.rb"
    run  "ln -nfs #{shared_path}/config/thin.yml #{release_path}/config/thin.yml"
  end
end

after "deploy:setup", "deploy:setup_config"
after "deploy:finalize_update", "deploy:symlink_config"

# Tasks to start/stop/restart the clockwork process.
namespace :clockwork do
  desc "Start clockwork"
  task :start, :roles =&gt; [:app] do
    run "cd #{current_path} &amp;&amp; RAILS_ENV=#{rails_env} bundle exec clockworkd -c #{current_path}/config/clock.rb --pid-dir #{shared_path}/pids --log --log-dir #{shared_path}/log start"
  end

  task :stop, :roles =&gt; [:app] do
    run "cd #{current_path} &amp;&amp; RAILS_ENV=#{rails_env} bundle exec clockworkd -c #{current_path}/config/clock.rb --pid-dir #{shared_path}/pids --log --log-dir #{shared_path}/log stop"
  end

  task :restart, :roles =&gt; [:app] do
    run "cd #{current_path} &amp;&amp; RAILS_ENV=#{rails_env} bundle exec clockworkd -c #{current_path}/config/clock.rb --pid-dir #{shared_path}/pids --log --log-dir #{shared_path}/log restart"
  end
end

after  "deploy:stop",    "clockwork:stop"
after  "deploy:start",   "clockwork:start"
before "deploy:restart", "clockwork:restart"

namespace :db do
  desc 'Seed your database for the first time'
  task :seed do
    run "cd #{current_path} &amp;&amp; psql -d discourse_production &lt; pg_dumps/production-image.sql"
  end
end

after  'deploy:update_code', 'deploy:migrate'
</code></pre>

<p>####5.运行Capistrano
初次安装部署</p>

<pre><code>bundle install
cap deploy:setup
cap deploy:cold #第一次运行之后更新重启的时候只需要 cap deploy 便可
</code></pre>

<p>升级部署</p>

<pre><code>git fetch upstream
git merge upstream/master
git push origin master
cap deploy
</code></pre>
]]></content:encoded>
    </item>
    
    <item>
      <title>Git修订版本</title>
      <link href="http://geeklu.com/2013/05/git-revisions/"/>
      <pubDate>2013-05-09T00:00:00+08:00</pubDate>
      <author>卢克</author>
      <guid>http://geeklu.com/2013/05/git-revisions</guid>
      <content:encoded><![CDATA[<p>在git中修订版本其实就是commit对象的名字，这个名字可以直接是sha1的哈希或者指向这个哈希的引用（比如分支或者tag）。git使用中，修订版本或者修订版本范围的指定是一个非常重要的知识点，因为很多git命令都需要接收这样的参数，即修订版本或者修订版本的范围。
指定修订版本往往是为了从这个指定的修订版本开始向回遍历所有的修订版本进行相关操作，而指定修订版本范围则是为了只对范围中的修订版本进行单独操作。
关于修订版本及其范围的指定方式可以在这里找到：<a href="https://www.kernel.org/pub/software/scm/git/docs/gitrevisions.html">https://www.kernel.org/pub/software/scm/git/docs/gitrevisions.html</a>。</p>

]]></content:encoded>
    </item>
    
  </channel>
</rss>
